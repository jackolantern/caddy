import os

import tatsu
import tatsu.model

import language.ext as ext
import language.syntax as syntax
from language.parser import CADDYParser # generated by tatsu from caddy.ebnf

from pretty import pretty, pprint

def class_names(obj):
    name = str(type(obj).__name__).split(".")[-1]
    yield name

class Transformer:
    def transform(self, node, *args, **kwargs):
        for name in class_names(node):
            func = getattr(self, f'transform_{name}', None)
            if func:
                return func(node, *args, **kwargs)
        return node

class DefaultTransformer(Transformer):
    def transform_Block(self, block, *args, **kwargs):
        statements = [self.transform(s, *args, **kwargs) for s in block.statements]
        expression = self.transform(block.expression, *args, **kwargs)
        return syntax.Block(statements, expression)

    def transform_Assignment(self, assign, *args, **kwargs):
        expression = self.transform(assign.expression, *args, **kwargs)
        return syntax.Assignment(assign.name, expression)

    def transform_Call(self, call, *args, **kwargs):
        expression = self.transform(call.expression, *args, **kwargs)
        arguments = [self.transform(arg, *args, **kwargs) for arg in call.arguments]
        return syntax.Call(expression, arguments)

    def transform_Array(self, array, *args, **kwargs):
        value = [self.transform(e, *args, **kwargs) for e in array.value]
        return syntax.Array(value)

    def transform_UnaryOperation(self, unaryop, *args, **kwargs):
        expression = self.transform(unaryop.expression, *args, **kwargs)
        return syntax.UnaryOperation(unaryop.op, expression)

    def transform_BinaryOperation(self, binop, *args, **kwargs):
        lhs = self.transform(binop.lhs, *args, **kwargs)
        rhs = self.transform(binop.rhs, *args, **kwargs)
        return syntax.BinaryOperation(binop.op, lhs, rhs)

    def transform_FunctionRef(self, function, *args, **kwargs):
        body = self.transform(function.body, *args, **kwargs)
        return syntax.FunctionRef(function.parameters, body)

    def transform_FunctionDef(self, function, *args, **kwargs):
        body = self.transform(function.body, *args, **kwargs)
        return syntax.FunctionDef(function.parameters, body)

    def transform_Namespace(self, ns, *args, **kwargs):
        definitions = [self.transform(d, *args, **kwargs) for d in self.definitions]
        return syntax.Namespace(definitions)

    def transform_IfThenElse(self, expr, *args, **kwargs):
        test = self.transform(expr.test, *args, **kwargs)
        true = self.transform(expr.true, *args, **kwargs)
        false = self.transform(expr.false, *args, **kwargs)
        return syntax.IfThenElse(test, true, false)

    def transform_Lookup(self, lookup, *args, **kwargs):
        expression = self.transform(lookup.expression, *args, **kwargs)
        return syntax.Lookup(expression, lookup.var)

    def transform_Index(self, index, *args, **kwargs):
        lhs = self.transform(index.lhs, *args, **kwargs)
        rhs = self.transform(index.rhs, *args, **kwargs)
        return syntax.Index(lhs, rhs)

class BindingTransform(DefaultTransformer):
    def transform_Variable(self, var, parameters, offset):
        if var.name == 'this':
            return syntax.Bound(var.name, 0)
        if var.name in parameters:
            index = parameters.index(var.name)
            return syntax.Bound(var.name, index + offset)
        return var

    def transform_FunctionDef(self, function, parameters, offset):
        names = [p.name for p in function.parameters]
        parameters = [p for p in parameters if p not in names]
        body = self.transform(function.body, parameters, offset + len(function.parameters) + 1)
        return syntax.FunctionDef(function.parameters, body)

class Scope:
    def __init__(self, parent, symbols=None):
        self.parent = parent
        self.symbols = symbols if symbols else {}

    def push(self):
        return Scope(self)

    def keys(self):
        if self.parent is None:
            return list(self.symbols.keys())
        else:
            return list(self.symbols.keys()) + self.parent.keys()

    def add_symbol(self, name, value):
        existing = self.symbols.get(name)
        if existing:
            raise Exception(f"This scope already defines a value named '{name}'.")
        else:
            while isinstance(value, syntax.Reference):
                value = value.value
            self.symbols[name] = value

    def find_symbol(self, name):
        symbol = self.symbols.get(name, None)
        if symbol:
            if isinstance(symbol, (syntax.Bound, syntax.Variable)):
                return symbol
            return syntax.Reference(name, symbol)
        if self.parent:
            return self.parent.find_symbol(name)
        else:
            return syntax.Variable(name)
            #raise Exception(f"No symbol named '{name}'.")

    def get_root(self):
        if self.parent:
            return self.parent.get_root()
        return self

class Semantics:
    def __init__(self, use_defaults=True):
        self.use_defaults = use_defaults

    def block_region(self, ast):
        return syntax.Block(ast[0], ast[1])

    def function(self, ast):
        return syntax.FunctionDef(ast.parameters, ast.body)

    def namespace(self, ast):
        return syntax.Namespace(ast)

    def import_file(self, ast):
        program = parse_file(ast.path.value)
        program = compile_program(program)
        return syntax.Import(ast.path, program)

    def assignment(self, ast):
        return syntax.Assignment(ast.name, ast.value)

    def definition(self, ast):
        return syntax.NamespaceDefinition(ast.name, ast.value)

    def function_call(self, ast):
        return syntax.Call(ast.function, ast.arguments)

    def relational_binary_operation(self, ast):
        return syntax.BinaryOperation(ast.op, ast.lhs, ast.rhs)

    def additive_binary_operation(self, ast):
        return syntax.BinaryOperation(ast.op, ast.lhs, ast.rhs)

    def multiplicative_binary_operation(self, ast):
        return syntax.BinaryOperation(ast.op, ast.lhs, ast.rhs)

    def unary_operation(self, ast):
        return syntax.UnaryOperation(ast.op, ast.inner)

    def lookup(self, ast):
        return syntax.Lookup(ast[0], ast[1])

    def chain(self, ast):
        return syntax.Call(ast.function, [ast.first] + ast.arguments)

    def if_then_else(self, ast):
        return syntax.IfThenElse(*ast)

    def variable(self, ast):
        return syntax.Variable(ast)

    def bool(self, ast):
        return syntax.Bool(ast == 'true')

    def number(self, ast):
        return syntax.Float(float(ast)) if '.' in ast else syntax.Int(int(ast))

    def string(self, ast):
        return syntax.String("".join(ast))

    def array(self, ast):
        return syntax.Array(list(ast))

    def index(self, ast):
        return syntax.Index(*ast)

class Compiler:
    def compile_block(self, block, scope):
        new = scope.push()
        for statement in block.statements:
            if isinstance(statement, syntax.Assignment):
                value = self.compile_expression(statement.expression, new)
                new.add_symbol(statement.name, value)
            elif isinstance(statement, syntax.Import):
                for d in statement.program.definitions:
                    value = self.compile_expression(d.value, new)
                    new.add_symbol(d.name, value)
            else:
                raise Exception("!")
        return self.compile_expression(block.expression, new)

    def compile_expression(self, expression, scope):
        if isinstance(expression, syntax.Block):
            return self.compile_block(expression, scope)
        if isinstance(expression, syntax.Variable):
            return scope.find_symbol(expression.name)
        if isinstance(expression, syntax.FunctionRef):
            return expression
        if isinstance(expression, syntax.FunctionDef):
            return self.compile_function(expression, scope)
        if isinstance(expression, syntax.Call):
            return self.compile_call(expression, scope)
        if isinstance(expression, syntax.BinaryOperation):
            return self.compile_binop(expression, scope)
        if isinstance(expression, syntax.UnaryOperation):
            return self.compile_unaryop(expression, scope)
        if isinstance(expression, syntax.Namespace):
            return self.compile_namespace(expression, scope)
        if isinstance(expression, syntax.Lookup):
            return self.compile_lookup(expression, scope)
        if isinstance(expression, syntax.IfThenElse):
            return self.compile_if_then_else(expression, scope)
        if isinstance(expression, syntax.Index):
            return self.compile_index(expression, scope)
        if isinstance(expression, syntax.Array):
            return self.compile_array(expression, scope)
        else:
            return expression
            #raise Exception(f"! compile_expression {type(expression)}")

    def compile_call(self, call, scope):
        expression = self.compile_expression(call.expression, scope)
        arguments = [self.compile_expression(arg, scope) for arg in call.arguments]
        return syntax.Call(expression, arguments)

    def compile_array(self, array, scope):
        value = [self.compile_expression(e, scope) for e in array.value]
        return syntax.Array(value)

    def compile_binop(self, binop, scope):
        lhs = self.compile_expression(binop.lhs, scope)
        rhs = self.compile_expression(binop.rhs, scope)
        return syntax.BinaryOperation(binop.op, lhs, rhs)

    def compile_unaryop(self, unaryop, scope):
        expression = self.compile_expression(unaryop.expression, scope)
        return syntax.UnaryOperation(unaryop.op, expression)

    def compile_function(self, function, scope):
        tr = BindingTransform()
        body = tr.transform(
            function.body, parameters=[p.name for p in function.parameters], offset=1)
        body = self.compile_expression(body, scope)
        new_function = syntax.FunctionRef(function.parameters, body)
        return new_function

    def compile_namespace(self, ns, scope):
        new = scope.push()
        definitions = []
        for definition in ns.definitions:
            value = self.compile_expression(definition.value, new)
            new.add_symbol(definition.name, value)
            definitions.append(syntax.NamespaceDefinition(definition.name, value))
        return syntax.Namespace(definitions)

    def compile_if_then_else(self, if_then_else, scope):
        test = self.compile_expression(if_then_else.test, scope)
        if isinstance(test, syntax.Bool):
            if test.value == True:
                return self.compile_expression(if_then_else.true, scope)
            else:
                assert(test.value == False)
                return self.compile_expression(if_then_else.false, scope)
        true = self.compile_expression(if_then_else.true, scope)
        false = self.compile_expression(if_then_else.false, scope)
        return syntax.IfThenElse(test, true, false)

    def compile_lookup(self, lookup, scope):
        expression = self.compile_expression(lookup.expression, scope)
        return syntax.Lookup(expression, lookup.var)

    def compile_index(self, index, scope):
        lhs = self.compile_expression(index.lhs, scope)
        rhs = self.compile_expression(index.rhs, scope)
        return syntax.Index(lhs, rhs)


def run_file(path, **kwargs):
    path = os.path.join(os.getcwd(), path)
    program = parse_file(path, **kwargs)
    program = compile_program(program, **kwargs)
    return run_compiled_program(program)

def run_string(string, **kwargs):
    program = parse_string(string, **kwargs)
    program = compile_program(program, **kwargs)
    return run_compiled_program(program)

def parse_file(path, **kwargs):
    path = os.path.join(os.getcwd(), path)
    with open(path, 'r') as fd:
        string = fd.read()
        return parse_string(string, **kwargs)

def parse_string(string, **kwargs):
    parser = CADDYParser() #tatsu.compile(grammar)
    return parser.parse(string, semantics=Semantics(**kwargs), comments_re="/\*.*?\*\/", eol_comments_re="//.*?$")

def compile_program(program, use_defaults=True):
    compiler = Compiler()
    scope = ext.make_global_scope() if use_defaults else Scope(None)
    return compiler.compile_block(program, scope)

def run_compiled_program(program):
    return program.run()

